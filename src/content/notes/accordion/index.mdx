---
status: "draft"
title: "Building an Accordion"
date: "2025-11-1"
summary: "Building an Accordion in React and Motion."
category: "Deep Dive"
thumbImage: "https://ucarecdn.com/058fca4d-9e96-47ad-9412-f730b87c2c13/-/preview/632x469/"
tags: ["components"]
---

# What is an Accordion?

An Accordion component is a very commonly interactive UI components seen on the web , You may have come across this component in an FAQ section , menu and sub-menus or feature list.

Accordion helps keep the ui clean by hiding information by default and revealing it when the user interacts with a section

# Anatomy of a Accordion Component

**Header :** The visible section of the accordion, it also act as an trigger.

**Panel :** The collapsed part , only visible when the accordion in opened.

**Body :** A wrapper around the both header and panel that holds them together.

**Indicator :** "+ / -"" or an caret ðŸ”½ that indicates the accordion is open or close , This is optional.

# A Basic Accordion

To start, I built a simple accordion using React state.

<ComponentBox>
  <BasicAccordion />
</ComponentBox>

```tsx
// BasicAccordion.tsx
const [openIndex, setOpenIndex] = useState<number | null>(null);
```

Only one panel can be open at a time. Clicking the same header again closes it.

```tsx
// BasicAccordion.tsx
const [openIndex, setOpenIndex] = useState<number | null>(null);
```

Each accordion item is rendered from a data array.

The panel is conditionally shown based on the active index.

```tsx
// BasicAccordion.tsx
{
  openIndex === id && <div className="p-4">{item.panel}</div>;
}
```

To indicate state visually, the arrow icon rotates when the panel is open.

```tsx
// BasicAccordion.tsx
"use client";
import clsx from "clsx";
import React, { useState } from "react";

const items = [
  {
    header: "header-1",
    panel: "Answer panel",
  },
  {
    header: "header-2",
    panel: "Answer panel",
  },
  {
    header: "header-3",
    panel: "Answer panel",
  },
];

const Accordion = () => {
  const [openIndex, setOpenIndex] = useState<number | null>(null);
  const toggleOpen = (index: number) => {
    setOpenIndex(openIndex === index ? null : index);
  };
  return (
    <div className="h-fit w-[60%]">
      {items.map((item, id) => (
        <div key={id} className="border border-neutral-200">
          <button
            className="flex w-full justify-between bg-neutral-200 p-2"
            onClick={() => toggleOpen(id)}
          >
            <div>{item.header}</div>
            <div
              className={clsx(
                "flex",
                openIndex === id ? "rotate-180" : "rotate-0",
              )}
            >
              <span className="rotate-0">ðŸ”½</span>
            </div>
          </button>
          {openIndex === id && (
            <div className="overflow-hidden p-4">{item.panel}</div>
          )}
        </div>
      ))}
    </div>
  );
};
export default Accordion;
```

# Thinking in React Components

This still works but it has few issue that hold it back from being a re-usable component.

- **Separation of Concerns** - Data, state, and presentation live in the same component.
- **Behavior option** - Single and multiple open panels
- **Accessibilities**

## Separation of concerns

**AccordionRoot** â†’ owns state and behavior

**AccordionItem** â†’ represents a single logical unit

**AccordionTrigger** â†’ handles user interaction

**AccordionHeader** â†’ visual header content

**AccordionPanel** â†’ collapsible content

```js
accordion/
â”œâ”€ root/
â”‚  â””â”€ AccordionRoot.tsx      // State + behavior
â”œâ”€ item/
â”‚  â””â”€ AccordionItem.tsx      // Item identity
â”œâ”€ trigger/
â”‚  â””â”€ AccordionTrigger.tsx   // Interaction logic
â”œâ”€ header/
â”‚  â””â”€ AccordionHeader.tsx    // Visual header
â”œâ”€ panel/
â”‚  â””â”€ AccordionPanel.tsx     // Collapsible content
â”œâ”€ context.ts                // Shared state
â”œâ”€ itemContext.ts            // Per-item context
â”œâ”€ types.ts                  // Shared types
â”œâ”€ Accordion.tsx             // Public exports
```

## Single vs Multiple Open Panels

- Default â†’ single open panel
- <InlineCode>multiple</InlineCode> prop â†’ allows multiple panels

Internally, the root switches between:

- a single value (<InlineCode>string | null</InlineCode>)
- a list of values (<InlineCode>string[]</InlineCode>)

This keeps the public API simple while allowing flexible behavior.

## Accessibility

- Interactive logic lives in <InlineCode>AccordionTrigger</InlineCode>
- Visual content stays in <InlineCode>AccordionHeader</InlineCode>
- State is centralized in the root

## React Patterns Used

- **Compound Components**
  Enables declarative composition and flexible APIs.
- **Context for Shared State**
  Avoids prop drilling and keeps state centralized.
- **Behavior-Based APIs**
  Exposes functions (<InlineCode>isOpen</InlineCode>, <InlineCode>toggleItem</InlineCode>) instead of raw state.
- **Boolean Configuration (<InlineCode>multiple</InlineCode>)**
  Keeps the API readable and intentional

# Implementation

## AccordionRoot

- Acts as the brain of the accordion.
- Owns all shared state
- Decides whether the accordion operates in single or multiple mode
- Exposes behavior (open, close, toggle) through context
- Coordinates all accordion items as a group

```tsx
"use client";
import React, { useState } from "react";
import { AccordionContext } from "../context";

type AccordionRootProps = {
  children: React.ReactNode;
  multiple?: boolean;
};

const AccordionRoot = ({ children, multiple = false }: AccordionRootProps) => {
  const [openItem, setOpenItem] = useState<string | null>(null);
  const [openItems, setOpenItems] = useState<string[]>([]);
  function toggleItem(value: string) {
    if (multiple) {
      setOpenItems((prev) =>
        prev.includes(value)
          ? prev.filter((item) => item !== value)
          : [...prev, value],
      );
    } else {
      setOpenItem((prev) => (prev === value ? null : value));
    }
  }

  const isOpen = (value: string) =>
    multiple ? openItems.includes(value) : openItem === value;

  return (
    <AccordionContext.Provider value={{ isOpen, toggleItem }}>
      {children}
    </AccordionContext.Provider>
  );
};

export default AccordionRoot;
```

All high-level decisions about how the accordion behaves live here.

<ComponentBox>
  <AccordionDemo />
</ComponentBox>
